"""
Flare Random Oracle - Secure Random Number from Coston2 Testnet

Fetches on-chain random numbers from Flare's RandomNumberV2 contract
(which lives at the same address as the Relay contract) and converts
them into actionable trading decisions.

Installation:
    pip install web3

Usage:
    oracle = FlareRandomOracle()
    result = oracle.get_random_decision()
    print(result)
    # {'raw': 7658424...154215, 'score': 42, 'decision': 'HOLD'}
"""

from web3 import Web3
from web3.middleware import ExtraDataToPOAMiddleware
from typing import Dict, Any


class FlareRandomOracle:
    """
    Oracle class for fetching secure random numbers from Flare's
    RandomNumberV2 contract on the Coston2 Testnet.

    The random number is generated by the Flare protocol's relay system
    and is cryptographically secure (sourced from FTSO commit-reveal rounds).
    """

    # Network Configuration
    RPC_URL = "https://coston2-api.flare.network/ext/C/rpc"
    CHAIN_ID = 114
    CONTRACT_REGISTRY_ADDRESS = "0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019"

    # Registry name -- "RandomNumberV2" (NOT "RandomNumberV2Interface")
    REGISTRY_CONTRACT_NAME = "RandomNumberV2"

    # Minimal ABI for ContractRegistry
    CONTRACT_REGISTRY_ABI = [
        {
            "inputs": [{"name": "name", "type": "string"}],
            "name": "getContractAddressByName",
            "outputs": [{"name": "", "type": "address"}],
            "stateMutability": "view",
            "type": "function"
        }
    ]

    # Minimal ABI for RandomNumberV2 (Relay contract)
    # getRandomNumber() -> uint256
    RANDOM_ABI = [
        {
            "inputs": [],
            "name": "getRandomNumber",
            "outputs": [{"name": "", "type": "uint256"}],
            "stateMutability": "view",
            "type": "function"
        }
    ]

    def __init__(self):
        """
        Initialize the FlareRandomOracle by connecting to Coston2 Testnet
        and resolving the RandomNumberV2 contract address from the registry.

        Raises:
            ConnectionError: If unable to connect to the RPC endpoint
            RuntimeError: If unable to resolve the contract address
        """
        self.w3 = Web3(Web3.HTTPProvider(self.RPC_URL))
        self.w3.middleware_onion.inject(ExtraDataToPOAMiddleware, layer=0)

        if not self.w3.is_connected():
            raise ConnectionError(
                f"Failed to connect to Flare Coston2 RPC at {self.RPC_URL}"
            )

        print(f"[OK] Connected to Flare Coston2 Testnet (Chain ID: {self.w3.eth.chain_id})")

        # Resolve contract address from registry
        registry = self.w3.eth.contract(
            address=Web3.to_checksum_address(self.CONTRACT_REGISTRY_ADDRESS),
            abi=self.CONTRACT_REGISTRY_ABI,
        )

        try:
            addr = registry.functions.getContractAddressByName(
                self.REGISTRY_CONTRACT_NAME
            ).call()
            self.random_address = Web3.to_checksum_address(addr)
        except Exception as e:
            raise RuntimeError(f"Failed to resolve {self.REGISTRY_CONTRACT_NAME}: {e}")

        print(f"[OK] {self.REGISTRY_CONTRACT_NAME} resolved to: {self.random_address}")

        self.random_contract = self.w3.eth.contract(
            address=self.random_address,
            abi=self.RANDOM_ABI,
        )

    def get_random_number(self) -> int:
        """
        Fetch the latest on-chain random number (raw uint256).

        Returns:
            int: A cryptographically secure 256-bit random integer

        Raises:
            RuntimeError: If the contract call fails
        """
        try:
            return self.random_contract.functions.getRandomNumber().call()
        except Exception as e:
            raise RuntimeError(f"Failed to fetch random number: {e}")

    def get_random_decision(self) -> Dict[str, Any]:
        """
        Fetch a random number and convert it into a trading decision.

        The raw 256-bit integer is normalized to a score between 0 and 100.
        The score determines the decision:
            - score > 66  -> "BUY"
            - score < 33  -> "SELL"
            - otherwise   -> "HOLD"

        Returns:
            dict: {
                'raw': int,         # The full 256-bit random number
                'score': int,       # Normalized score (0-100)
                'decision': str     # "BUY", "SELL", or "HOLD"
            }

        Raises:
            RuntimeError: If the contract call fails
        """
        raw = self.get_random_number()

        # Normalize to 0-100 range
        score = raw % 101

        # Map score to decision
        if score > 66:
            decision = "BUY"
        elif score < 33:
            decision = "SELL"
        else:
            decision = "HOLD"

        return {
            "raw": raw,
            "score": score,
            "decision": decision,
        }


def main():
    """Test the FlareRandomOracle."""
    print("=" * 60)
    print("Flare Random Oracle - Coston2 Testnet")
    print("=" * 60)
    print()

    try:
        oracle = FlareRandomOracle()
        print()

        print("Fetching on-chain random decision...")
        print("-" * 60)

        result = oracle.get_random_decision()
        print(f"\n  Raw (first 40 chars): {str(result['raw'])[:40]}...")
        print(f"  Score:    {result['score']} / 100")
        print(f"  Decision: {result['decision']}")

        print("\n" + "=" * 60)
        print("[OK] Test completed successfully!")
        print("=" * 60)

    except Exception as e:
        print(f"\n[FAIL] Fatal error: {e}")
        raise


if __name__ == "__main__":
    main()
